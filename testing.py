from optparse import Option
import yaml

from yaml.loader import SafeLoader

from typing import Final, List

from pathlib import Path

# python3 -m pip install GitPython
from git import Repo

# python3 -m pip install pydantic
from pydantic import BaseModel

import os
import re


class RepoFile(BaseModel):
    path:   str
    errors: int


class Repository(BaseModel):
    author:  str
    commit:  str
    files:   List[RepoFile]
    project: str
    url:     str


class Repositories(BaseModel):
    repositories: List[Repository]



def create_repo_unit_test(repo: Repository) -> None:
    base_path:      Final[str] = os.path.join('..', 'thirdparty', repo.author, repo.project)
    unit_test_path: Final[str] = os.path.join('test', 'src', 'Misc', f'Test_{repo.author}_{repo.project}.cpp')

    with open(unit_test_path, 'w') as f:
        preamble: Final[str] = """// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT MODIFY IT!


#include <filesystem>

#include <catch2/catch.hpp>

#include <Parser.hpp>

#include "Helper.hpp"


namespace fs = std::filesystem;"""

        f.write(preamble)

        for file in repo.files:
            file_name: Final[str] = os.path.basename(file.path)
            full_path: Final[str] = os.path.normpath(os.path.join(base_path, file.path))
            unit_test: Final[str] = f"""


TEST_CASE("{repo.author} - {repo.project} - {file_name} : Check File {full_path}", "[Misc]")
{{
    const fs::path inputFile{{"{full_path}"}};

    Parser parser{{inputFile}};
    Library lib = parser.parseLibrary();
    REQUIRE(parser.getFileErrCtr() <= {file.errors});
    check_error_count(inputFile, parser.getFileErrCtr(), {file.errors});
}}"""

            f.write(unit_test)



def readRepoYaml(yamlPath: str) -> Repositories:
    with open(yamlPath, 'r') as f:
        data: Final[Repositories] = Repositories(**list(yaml.load_all(f, Loader=SafeLoader))[0])

    return data


def createUnitTestFiles(data: Repositories) -> None:
    for repo in data.repositories:
        create_repo_unit_test(repo)


def writeRepoYaml(yamlPath: str, data: Repositories) -> None:
    with open(yamlPath, 'w') as f:
        yaml.dump(data.dict(), f)


def getRepoByUrl(data: Repositories, url: str) -> Repository:
    for repo in data.repositories:
        if repo.url == url:
            return repo

    raise Exception(f'Did not find repository with URL `{url}`')


def getRepoByName(data: Repositories, author: str, project: str) -> Repository:
    for repo in data.repositories:
        if repo.author == author and repo.project == project:
            return repo

    raise Exception(f'Did not find repository with author `{author}` and project `{project}`')


def getFileByPath(repo: Repository, path: str) -> RepoFile:
    for file in repo.files:
        if file.path == path:
            return file

    raise Exception(f'Did not find repository file with path `{path}`')


def addUpdateRepoFile(repo: Repository, repo_file: RepoFile) -> None:

    found_file: bool = False

    for file in repo.files:
        if file.path == repo_file.path:
            found_file = True

            if file.errors > repo_file.errors:
                file.errors = repo_file.errors

    if not found_file:
        repo.files += [repo_file]


def writeBackErrorCount(data: Repositories) -> None:
    logFilePath: Final[str] = 'test/test_err_cnt.log'

    with open(logFilePath, 'r') as f:
        log = f.readlines()

    for logLine in log:
        regex: Final[str] = "^Expected \s*(\d+)\s* errors and got \s*(\d+)\s* errors in `(.*)`$"

        matches = re.findall(regex, logLine)[0]

        expectedErrCnt: Final[int] = int(matches[0])
        actualErrCnt:   Final[int] = int(matches[1])
        filePath:             str  = str(matches[2])

        author:  Final[str] = filePath.split(os.path.sep)[2]
        project: Final[str] = filePath.split(os.path.sep)[3]

        filePath = os.path.relpath(filePath, os.path.join('..', 'thirdparty', author, project))
        filePath = os.path.join('.', filePath)

        repo: Final[Repository] = getRepoByName(data, author, project)
        file: Final[RepoFile]   = getFileByPath(repo, filePath)

        if file.errors > actualErrCnt:
            file.errors = actualErrCnt



def get_repos(data: Repositories, repo_dir: str) -> None:
    for repo in data.repositories:

        export_dir: Final[str] = os.path.join(repo_dir, repo.author, repo.project)

        print(f'Cloning {repo.url} to {export_dir} ...')

        try:
            repo = Repo.clone_from(repo.url, export_dir)

            # @todo Use commit hash from repos.yaml
            commit = repo.head.commit

            print(f'Using Commit {commit}')

            repo.git.checkout(commit)
        except:
            print(f'Failed cloning repository from `{repo.url}`!')



if __name__ == '__main__':

    inputYaml: Final[str] = 'repos.yaml'

    data: Repositories = readRepoYaml(inputYaml)

    createUnitTestFiles(data)

    # exit()

    # outputYaml: Final[str] = 'repos3.yaml'

    # writeBackErrorCount(data)

    # writeRepoYaml(outputYaml, data)


    # get_repos(data, '/home/dom/Desktop/Git/OpenOrCadParser/thirdparty')


    # basePath: Final = Path('/home/dom/Desktop/Git/OpenOrCadParser/thirdparty')
    # fileExtensions: Final[List[str]] = ['*.OBK', '*.OLB', '*.DSN', '*.DBK']

    # for author_dir in basePath.glob('*'):
    #     if not author_dir.is_dir():
    #         continue

    #     author: str = os.path.basename(author_dir)

    #     for project_dir in author_dir.glob('*'):
    #         if not project_dir.is_dir():
    #             continue

    #         project: str = os.path.basename(project_dir)

    #         commit = 'None'
    #         # cur_repo = Repo(project_dir)
    #         # commit = cur_repo.head.commit
    #         # del cur_repo

    #         repo: Repository = getRepoByName(data, author, project)

    #         if repo.commit == 'None':
    #             repo.commit = commit

    #         for extension in fileExtensions:
    #             for file in project_dir.rglob(extension):
    #                 file = os.path.join('.', os.path.relpath(file, project_dir))
    #                 repo_file: Final[RepoFile] = RepoFile(path=file, errors=99999)
    #                 addUpdateRepoFile(repo, repo_file)


    # writeRepoYaml(outputYaml, data)

    # createUnitTestFiles(data)



